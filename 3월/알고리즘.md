# 03.14
## 자료구조
- 선형
- 비선형
  - tree
    - 단방향
    - 부모자식
    - 싸이클 발생 x
    - 루트노드, 리프노드
## 그래프 탐색 방법
- 인접행렬 -> 2차원 리스트
- 인접리스트
- 1차배열(트리가 2진트리)
### 인접행렬
```py
name = ['Amy', 'Bob', 'Chloe', 'Diane', 'Edger']
arr = [[0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0]]
max = 0
max_index = 0
for i in range(5):
    sum = 0
    for j in range(5):
        if arr[j][i] == 1:
            sum += arr[j][i]
    if sum > max:
        max = sum
        max_index = i
print(name[max_index])
```
### DFS (tree)
```py
name = ['A','B','C','D','E','F']

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]
used = []

def dfs(now):
    used.append(now)

    for i in range(n):
        if arr[now][i] == 1:
            dfs(i)
dfs(0)
print(*used)
```
### DFS (tree x)
```py
name = list(input().split()) # b a c d
arr = [[0, 0, 1, 1],
       [1, 0, 0, 0],
       [0, 1, 0, 1],
       [0, 0, 0, 0]]

used=[0]*4
answer=[]
def dfs(now):

    global answer
    answer.append(name[now])

    for x in range(4):
        if arr[now][x] == 1:
            if used[x]==0:
                used[x]=1
                dfs(x)
used[0]=1  #  b부터 탐색 시작 b의 인덱스는 0이고
              # used[시작인덱스]=1 체크
dfs(0)
print(*answer)
```
### DFS (tree x, 경로 여러개 탐색)
```py
name = list(input().split()) # b a c d
arr = [[0, 0, 1, 1],
       [1, 0, 1, 0],
       [1, 0, 0, 1],
       [0, 0, 0, 0]]

used=[0]*4
answer=0
def dfs(now):

    global answer
    if now==3:
        answer+=1
    for x in range(4):
        if arr[now][x] == 1:
            if used[x]==0:
                used[x]=1
                dfs(x)
                used[x]=0

used[1]=1
dfs(1)
print(answer)
```
### BFS(tree)
```py
from collections import deque
name = list(input().split()) # A B C D E F
arr = [[0, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]]

answer = []
def bfs(st):
       global answer
       q = deque()
       q.append(st)

       while q:
              now=q.popleft()
              answer.append(name[now])

              for x in range(6):
                     if arr[now][x] == 1:
                            q.append(x)

bfs(0)  # 탐색 시작 인덱스 넣고 호출하기
print(*answer)
```
### BFS(tree x)
```py
from collections import deque
name = list(input().split())
arr = [[0, 0, 1, 1],
       [1, 0, 0, 1],
       [1, 0, 0, 1],
       [0, 0, 0, 0]]
used=[0]*4
answer = []
def bfs(st):
    global answer

    q=deque()
    q.append(st)
    while q:
        now=q.popleft()
        answer.append(name[now])

        for x in range(4):
              if arr[now][x]==1:
                     if used[x]==0:
                        used[x]=1
                        q.append(x)

used[0]=1
bfs(0)
print(*answer)
```
# 03.15
### BFS(flood)
```py
from collections import deque
N = int(input())  # 3
y,x= map(int, input().split())  # 1,1  시작좌표 입력
arr = [[0] * N for _ in range(N)]  # n*n 사이즈 배열을 0으로 초기화

arr[y][x] = 1
q = deque()
q.append([y,x])


while q:
    now = q.popleft()   # 초기값 now 1,1
    y, x = now[0], now[1] # y = 1, x = 1
    directy = [-1,1,0,0]
    directx = [0,0,-1,1]

    for i in range(4):
        dy=y+directy[i]
        dx=x+directx[i]
        if 0 <= dy < N and 0 <= dx < N: # 배열 범위 벗어나지 않는다면
            if arr[dy][dx] == 0: #아직 바이러스가 퍼진 곳이 아니라면
                arr[dy][dx] = arr[y][x] + 1
                q.append([dy, dx])


for i in arr:
    print(*i)
```
# 03.16
### mincoding 29,30,31