# 03.14
## 자료구조
- 선형
- 비선형
  - tree
    - 단방향
    - 부모자식
    - 싸이클 발생 x
    - 루트노드, 리프노드
## 그래프 탐색 방법
- 인접행렬 -> 2차원 리스트
- 인접리스트
- 1차배열(트리가 2진트리)
### 인접행렬
```py
name = ['Amy', 'Bob', 'Chloe', 'Diane', 'Edger']
arr = [[0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0]]
max = 0
max_index = 0
for i in range(5):
    sum = 0
    for j in range(5):
        if arr[j][i] == 1:
            sum += arr[j][i]
    if sum > max:
        max = sum
        max_index = i
print(name[max_index])
```
### DFS (tree)
```py
name = ['A','B','C','D','E','F']

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]
used = []

def dfs(now):
    used.append(now)

    for i in range(n):
        if arr[now][i] == 1:
            dfs(i)
dfs(0)
print(*used)
```
### DFS (tree x)
```py
name = list(input().split()) # b a c d
arr = [[0, 0, 1, 1],
       [1, 0, 0, 0],
       [0, 1, 0, 1],
       [0, 0, 0, 0]]

used=[0]*4
answer=[]
def dfs(now):

    global answer
    answer.append(name[now])

    for x in range(4):
        if arr[now][x] == 1:
            if used[x]==0:
                used[x]=1
                dfs(x)
used[0]=1  #  b부터 탐색 시작 b의 인덱스는 0이고
              # used[시작인덱스]=1 체크
dfs(0)
print(*answer)
```
### DFS (tree x, 경로 여러개 탐색)
```py
name = list(input().split()) # b a c d
arr = [[0, 0, 1, 1],
       [1, 0, 1, 0],
       [1, 0, 0, 1],
       [0, 0, 0, 0]]

used=[0]*4
answer=0
def dfs(now):

    global answer
    if now==3:
        answer+=1
    for x in range(4):
        if arr[now][x] == 1:
            if used[x]==0:
                used[x]=1
                dfs(x)
                used[x]=0

used[1]=1
dfs(1)
print(answer)
```
### BFS(tree)
```py
from collections import deque
name = list(input().split()) # A B C D E F
arr = [[0, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]]

answer = []
def bfs(st):
       global answer
       q = deque()
       q.append(st)

       while q:
              now=q.popleft()
              answer.append(name[now])

              for x in range(6):
                     if arr[now][x] == 1:
                            q.append(x)

bfs(0)  # 탐색 시작 인덱스 넣고 호출하기
print(*answer)
```
### DFS (중복x)
```py
def dfs(level):
    global n
    if level == 3:
        for k in range(len(used_list)):
            if used_list[k] == used:
                return
        for j in range(len(used)):
            used_list[n][j] = used[j]
        n += 1
        for i in range(3):
            print(path[i],end='')
        print()
        return
    for j in range(len(arr)):
        path.append(arr[j])
        used[j] += 1
        dfs(level+1)
        path.pop()
        used[j] -= 1


arr = list(input())
path = []
used = [0] * len(arr)
used_list = [[0]*len(arr) for _ in range(200)]
n = 0
dfs(0)
```
## DFS (조합)
```py
name='tkbs'
path=['']*3

def abc(level,start):
    global path,name
    if level==3:
        for i in range(3):
            print(path[i],end=' ')
        print()
        return
    for i in range(start,4):
        path[level]=name[i]
        abc(level+1,i+1)
        path[level]=0

abc(0,0)
```
### BFS(tree x)
```py
from collections import deque
name = list(input().split())
arr = [[0, 0, 1, 1],
       [1, 0, 0, 1],
       [1, 0, 0, 1],
       [0, 0, 0, 0]]
used=[0]*4
answer = []
def bfs(st):
    global answer

    q=deque()
    q.append(st)
    while q:
        now=q.popleft()
        answer.append(name[now])

        for x in range(4):
              if arr[now][x]==1:
                     if used[x]==0:
                        used[x]=1
                        q.append(x)

used[0]=1
bfs(0)
print(*answer)
```
# 03.15
### BFS(flood)
```py
from collections import deque
N = int(input())  # 3
y,x= map(int, input().split())  # 1,1  시작좌표 입력
arr = [[0] * N for _ in range(N)]  # n*n 사이즈 배열을 0으로 초기화

arr[y][x] = 1
q = deque()
q.append([y,x])


while q:
    now = q.popleft()   # 초기값 now 1,1
    y, x = now[0], now[1] # y = 1, x = 1
    directy = [-1,1,0,0]
    directx = [0,0,-1,1]

    for i in range(4):
        dy=y+directy[i]
        dx=x+directx[i]
        if 0 <= dy < N and 0 <= dx < N: # 배열 범위 벗어나지 않는다면
            if arr[dy][dx] == 0: #아직 바이러스가 퍼진 곳이 아니라면
                arr[dy][dx] = arr[y][x] + 1
                q.append([dy, dx])

for i in arr:
    print(*i)
```
# 03.16
### mincoding 29,30,31

# 03.17
### union find
양방향 그래프에서 cycle 존재여부 확인 가능
```py
def findboss(member):
    if arr[ord(member)] == 0:
        return member
    ret = findboss(arr[ord(member)])
    arr[ord(member)] = ret
    return ret
def union(a,b):
    fa, fb = findboss(a),findboss(b)
    if fa == fb:
        return
    arr[ord(fb)] = fa
arr = [0]*200
union('A','B')
print(arr[ord('B')])
```
### union find cycle
```py
n = int(input())
edge = []
for _ in range(n):
    edge.append(input().split())


arr=[0]*200

def findboss(member):
    global arr
    if arr[ord(member)]==0:
        return member
    ret=findboss(arr[ord(member)])
    arr[ord(member)]=ret
    return ret

def union(a,b):
    global arr
    fa,fb=findboss(a),findboss(b)
    if fa==fb:
        return 1
    arr[ord(fb)]=fa

answer = "미발견"
for i in range(n):
    a, b = edge[i]
    ret = union(a, b)
    if ret==1:
        answer = "발견"
        break
print(answer)
```
### 최소 신장 트리

### 크루스칼
```py
n = int(input())
edge = [list(input().split()) for _ in range(n)]
for i in range(n):
    edge[i][2] = int(edge[i][2])
edge.sort(key = lambda x:x[2])
arr=[0]*200
def findboss(member):
    global arr
    if arr[ord(member)]==0:
        return member
    ret=findboss(arr[ord(member)])
    arr[ord(member)]=ret
    return ret

def union(a,b):
    global arr
    fa,fb=findboss(a),findboss(b)
    if fa==fb:
        return 1
    arr[ord(fb)]=fa

sum = 0
for j in range(len(edge)):
    a, b = edge[j][0], edge[j][1]
    if union(a,b) == 1:
        continue
    union(a,b)
    sum += edge[j][2]
print(sum)
```
### 삽입 정렬 (mincoding 32-1)
```py
n = int(input())
arr = [list(input().split()) for _ in range(n)]
for i in range(n):
    arr[i][0] = int(arr[i][0])
key = 1
while key != n:
    point = key
    for i in range(key-1, -1, -1):
        if arr[point][0] < arr[i][0]:
            arr[point], arr[i] = arr[i], arr[point]
            point -= 1
        elif arr[point][0] == arr[i][0]:
            if arr[point][1] < arr[i][1]:
                arr[point], arr[i] = arr[i], arr[point]
                point -= 1
    key += 1
for k in range(n):
    print(arr[k][0], arr[k][1])
```
### mincoding(33-5)
춘추전국시대
```py
def findboss(member):
    if bucket[ord(member)] == 0:
        return member
    ret = findboss(bucket[ord(member)])
    bucket[ord(member)] = ret
    return ret

def union(a,b):
    fa, fb = findboss(a), findboss(b)
    if fa == fb:
        return
    bucket[ord(b)] = fa

def war(a,b):
    fa = findboss(a) # A
    fb = findboss(b) # D
    la = [fa]
    lb = [fb]
    for j in range(len(name)):
        if name[j] == fa:
            ia = j # 0
        elif name[j] == fb:
            ib = j # 3
    for i in range(len(bucket)):
        if bucket[i] == fa:
            la.append(chr(i))
            for k in range(len(name)):
                if name[k] == chr(i):
                    ik = k
                    people[ia] += people[ik]
        elif bucket[i] == fb:
            lb.append(chr(i))
            for k in range(len(name)):
                if name[k] == chr(i):
                    ik = k
                    people[ib] += people[ik]
    if people[ia] > people[ib]:
        for i in range(len(la)):
            name.pop(name.index(la[i]))
    else:
        for j in range(len(lb)):
            name.pop(name.index(lb[j]))

n = int(input())
name = ['A','B','C','D','E','F','G']
people = list(map(int, input().split()))
bucket = [0] * 200
k = int(input())
sim = [list(input().split()) for _ in range(k)]
for i in range(k):
    if sim[i][0] == 'alliance':
        union(sim[i][1], sim[i][2])
    else:
        war(sim[i][1], sim[i][2])
print(len(name))
```
# 03.22
### 미로찾기
```py
arr=[[0,0,0,0],[1,0,1,0],[1,0,1,0],[0,0,0,0]]
visit=[[0] * 4 for _ in range(4)]
flag=0

def dfs(y,x):
    global flag
    if y==3 and x==3:
        flag=1
        return

    directy=[-1,1,0,0]
    directx=[0,0,-1,1]
    for i in range(4):
        dy=y+directy[i]
        dx=x+directx[i]

        if dy < 0 or dy > 3 or dx < 0 or dx > 3: continue  # 배열범위
        if visit[dy][dx] == 1: continue # 방문했던곳
        if arr[dy][dx]==1: continue  # 벽이면 않됨

        visit[dy][dx]=1
        dfs(dy,dx)
        #if flag: return

visit[0][0]=1
dfs(0,0)
if flag: print("가능")
else: print("불가능")
```
### 원상복구-1
```py
arr=[3,7,4,2]
Max=-21e8

def dfs(level):

    global  Max

    if level==4:
        gop=1
        for i in range(4):
            gop*=arr[i]
            Max=max(Max,gop)
        return

    backup=arr[level]

    arr[level]*=2
    dfs(level+1)
    arr[level]=backup     # 원상복구

    arr[level]/=3
    dfs(level+1)
    arr[level]=backup    # 원상복구 arr[level]*=3 (X)

    arr[level]+=5
    dfs(level+1)
    arr[level]=backup   # 원상복구

dfs(0)
print(Max)
```
### 원상복구-2
```py
def dfs(level,y,x):
    global max
    if level == 3:
        sum = 0
        for i in range(3):
            for j in range(3):
                sum += arr[i][j]
        if sum > max:
            max = sum
        return
    backup = [[0] * 3 for _ in range(3)]
    directy = [1,-1,0,0]
    directx = [0,0,1,-1]
    backup[y][x] = arr[y][x]
    arr[y][x] = (arr[y][x]*7)%10
    for i in range(4):
        dy = y+directy[i]
        dx = x+directx[i]
        if dy<0 or dy>2 or dx<0 or dx>2:
            continue
        backup[dy][dx] = arr[dy][dx]
        arr[dy][dx] = (arr[dy][dx] *7) %10
    for i in range(3):
        for j in range(3):
            dfs(level+1,i,j)
            for k in range(4):
                dy = y + directy[k]
                dx = x + directx[k]
                if dy < 0 or dy > 2 or dx < 0 or dx > 2:
                    continue
                arr[dy][dx] = backup[dy][dx]
            arr[y][x] = backup[y][x]
    arr[y][x] = backup[y][x]
    for i in range(4):
        dy = y+directy[i]
        dx = x+directx[i]
        if dy<0 or dy>2 or dx<0 or dx>2:
            continue
        arr[dy][dx] = backup[dy][dx]
arr=[
    [4,7,1],
    [3,5,8],
    [9,2,7]
]
max = 0
for i in range(3):
    for j in range(3):
        dfs(0, i, j)
print(max)
```