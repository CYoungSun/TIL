# 03.14
## 자료구조
- 선형
- 비선형
  - tree
    - 단방향
    - 부모자식
    - 싸이클 발생 x
    - 루트노드, 리프노드
## 그래프 탐색 방법
- 인접행렬 -> 2차원 리스트
- 인접리스트
- 1차배열(트리가 2진트리)
### 인접행렬
```py
name = ['Amy', 'Bob', 'Chloe', 'Diane', 'Edger']
arr = [[0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0]]
max = 0
max_index = 0
for i in range(5):
    sum = 0
    for j in range(5):
        if arr[j][i] == 1:
            sum += arr[j][i]
    if sum > max:
        max = sum
        max_index = i
print(name[max_index])
```
### DFS (tree)
```py
name = ['A','B','C','D','E','F']

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]
used = []

def dfs(now):
    used.append(now)

    for i in range(n):
        if arr[now][i] == 1:
            dfs(i)
dfs(0)
print(*used)
```
### DFS (tree x)
```py
name = list(input().split()) # b a c d
arr = [[0, 0, 1, 1],
       [1, 0, 0, 0],
       [0, 1, 0, 1],
       [0, 0, 0, 0]]

used=[0]*4
answer=[]
def dfs(now):

    global answer
    answer.append(name[now])

    for x in range(4):
        if arr[now][x] == 1:
            if used[x]==0:
                used[x]=1
                dfs(x)
used[0]=1  #  b부터 탐색 시작 b의 인덱스는 0이고
              # used[시작인덱스]=1 체크
dfs(0)
print(*answer)
```
### DFS (tree x, 경로 여러개 탐색)
```py
name = list(input().split()) # b a c d
arr = [[0, 0, 1, 1],
       [1, 0, 1, 0],
       [1, 0, 0, 1],
       [0, 0, 0, 0]]

used=[0]*4
answer=0
def dfs(now):

    global answer
    if now==3:
        answer+=1
    for x in range(4):
        if arr[now][x] == 1:
            if used[x]==0:
                used[x]=1
                dfs(x)
                used[x]=0

used[1]=1
dfs(1)
print(answer)
```
### BFS(tree)
```py
from collections import deque
name = list(input().split()) # A B C D E F
arr = [[0, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0]]

answer = []
def bfs(st):
       global answer
       q = deque()
       q.append(st)

       while q:
              now=q.popleft()
              answer.append(name[now])

              for x in range(6):
                     if arr[now][x] == 1:
                            q.append(x)

bfs(0)  # 탐색 시작 인덱스 넣고 호출하기
print(*answer)
```
### DFS (중복x)
```py
def dfs(level):
    global n
    if level == 3:
        for k in range(len(used_list)):
            if used_list[k] == used:
                return
        for j in range(len(used)):
            used_list[n][j] = used[j]
        n += 1
        for i in range(3):
            print(path[i],end='')
        print()
        return
    for j in range(len(arr)):
        path.append(arr[j])
        used[j] += 1
        dfs(level+1)
        path.pop()
        used[j] -= 1


arr = list(input())
path = []
used = [0] * len(arr)
used_list = [[0]*len(arr) for _ in range(200)]
n = 0
dfs(0)
```
## DFS (조합)
```py
name='tkbs'
path=['']*3

def abc(level,start):
    global path,name
    if level==3:
        for i in range(3):
            print(path[i],end=' ')
        print()
        return
    for i in range(start,4):
        path[level]=name[i]
        abc(level+1,i+1)
        path[level]=0

abc(0,0)
```
### BFS(tree x)
```py
from collections import deque
name = list(input().split())
arr = [[0, 0, 1, 1],
       [1, 0, 0, 1],
       [1, 0, 0, 1],
       [0, 0, 0, 0]]
used=[0]*4
answer = []
def bfs(st):
    global answer

    q=deque()
    q.append(st)
    while q:
        now=q.popleft()
        answer.append(name[now])

        for x in range(4):
              if arr[now][x]==1:
                     if used[x]==0:
                        used[x]=1
                        q.append(x)

used[0]=1
bfs(0)
print(*answer)
```
# 03.15
### BFS(flood)
```py
from collections import deque
N = int(input())  # 3
y,x= map(int, input().split())  # 1,1  시작좌표 입력
arr = [[0] * N for _ in range(N)]  # n*n 사이즈 배열을 0으로 초기화

arr[y][x] = 1
q = deque()
q.append([y,x])


while q:
    now = q.popleft()   # 초기값 now 1,1
    y, x = now[0], now[1] # y = 1, x = 1
    directy = [-1,1,0,0]
    directx = [0,0,-1,1]

    for i in range(4):
        dy=y+directy[i]
        dx=x+directx[i]
        if 0 <= dy < N and 0 <= dx < N: # 배열 범위 벗어나지 않는다면
            if arr[dy][dx] == 0: #아직 바이러스가 퍼진 곳이 아니라면
                arr[dy][dx] = arr[y][x] + 1
                q.append([dy, dx])

for i in arr:
    print(*i)
```
# 03.16
### mincoding 29,30,31

# 03.17
### union find
양방향 그래프에서 cycle 존재여부 확인 가능
```py
def findboss(member):
    if arr[ord(member)] == 0:
        return member
    ret = findboss(arr[ord(member)])
    arr[ord(member)] = ret
    return ret
def union(a,b):
    fa, fb = findboss(a),findboss(b)
    if fa == fb:
        return
    arr[ord(fb)] = fa
arr = [0]*200
union('A','B')
print(arr[ord('B')])
```
### union find cycle
```py
n = int(input())
edge = []
for _ in range(n):
    edge.append(input().split())


arr=[0]*200

def findboss(member):
    global arr
    if arr[ord(member)]==0:
        return member
    ret=findboss(arr[ord(member)])
    arr[ord(member)]=ret
    return ret

def union(a,b):
    global arr
    fa,fb=findboss(a),findboss(b)
    if fa==fb:
        return 1
    arr[ord(fb)]=fa

answer = "미발견"
for i in range(n):
    a, b = edge[i]
    ret = union(a, b)
    if ret==1:
        answer = "발견"
        break
print(answer)
```
### 최소 신장 트리

### 크루스칼
```py
n = int(input())
edge = [list(input().split()) for _ in range(n)]
for i in range(n):
    edge[i][2] = int(edge[i][2])
edge.sort(key = lambda x:x[2])
arr=[0]*200
def findboss(member):
    global arr
    if arr[ord(member)]==0:
        return member
    ret=findboss(arr[ord(member)])
    arr[ord(member)]=ret
    return ret

def union(a,b):
    global arr
    fa,fb=findboss(a),findboss(b)
    if fa==fb:
        return 1
    arr[ord(fb)]=fa

sum = 0
for j in range(len(edge)):
    a, b = edge[j][0], edge[j][1]
    if union(a,b) == 1:
        continue
    union(a,b)
    sum += edge[j][2]
print(sum)
```
### 삽입 정렬 (mincoding 32-1)
```py
n = int(input())
arr = [list(input().split()) for _ in range(n)]
for i in range(n):
    arr[i][0] = int(arr[i][0])
key = 1
while key != n:
    point = key
    for i in range(key-1, -1, -1):
        if arr[point][0] < arr[i][0]:
            arr[point], arr[i] = arr[i], arr[point]
            point -= 1
        elif arr[point][0] == arr[i][0]:
            if arr[point][1] < arr[i][1]:
                arr[point], arr[i] = arr[i], arr[point]
                point -= 1
    key += 1
for k in range(n):
    print(arr[k][0], arr[k][1])
```
### mincoding(33-5)
춘추전국시대
```py
def findboss(member):
    if bucket[ord(member)] == 0:
        return member
    ret = findboss(bucket[ord(member)])
    bucket[ord(member)] = ret
    return ret

def union(a,b):
    fa, fb = findboss(a), findboss(b)
    if fa == fb:
        return
    bucket[ord(b)] = fa

def war(a,b):
    fa = findboss(a) # A
    fb = findboss(b) # D
    la = [fa]
    lb = [fb]
    for j in range(len(name)):
        if name[j] == fa:
            ia = j # 0
        elif name[j] == fb:
            ib = j # 3
    for i in range(len(bucket)):
        if bucket[i] == fa:
            la.append(chr(i))
            for k in range(len(name)):
                if name[k] == chr(i):
                    ik = k
                    people[ia] += people[ik]
        elif bucket[i] == fb:
            lb.append(chr(i))
            for k in range(len(name)):
                if name[k] == chr(i):
                    ik = k
                    people[ib] += people[ik]
    if people[ia] > people[ib]:
        for i in range(len(la)):
            name.pop(name.index(la[i]))
    else:
        for j in range(len(lb)):
            name.pop(name.index(lb[j]))

n = int(input())
name = ['A','B','C','D','E','F','G']
people = list(map(int, input().split()))
bucket = [0] * 200
k = int(input())
sim = [list(input().split()) for _ in range(k)]
for i in range(k):
    if sim[i][0] == 'alliance':
        union(sim[i][1], sim[i][2])
    else:
        war(sim[i][1], sim[i][2])
print(len(name))
```
# 03.22
### 미로찾기
```py
arr=[[0,0,0,0],[1,0,1,0],[1,0,1,0],[0,0,0,0]]
visit=[[0] * 4 for _ in range(4)]
flag=0

def dfs(y,x):
    global flag
    if y==3 and x==3:
        flag=1
        return

    directy=[-1,1,0,0]
    directx=[0,0,-1,1]
    for i in range(4):
        dy=y+directy[i]
        dx=x+directx[i]

        if dy < 0 or dy > 3 or dx < 0 or dx > 3: continue  # 배열범위
        if visit[dy][dx] == 1: continue # 방문했던곳
        if arr[dy][dx]==1: continue  # 벽이면 않됨

        visit[dy][dx]=1
        dfs(dy,dx)
        #if flag: return

visit[0][0]=1
dfs(0,0)
if flag: print("가능")
else: print("불가능")
```
### 원상복구-1
```py
arr=[3,7,4,2]
Max=-21e8

def dfs(level):

    global  Max

    if level==4:
        gop=1
        for i in range(4):
            gop*=arr[i]
            Max=max(Max,gop)
        return

    backup=arr[level]

    arr[level]*=2
    dfs(level+1)
    arr[level]=backup     # 원상복구

    arr[level]/=3
    dfs(level+1)
    arr[level]=backup    # 원상복구 arr[level]*=3 (X)

    arr[level]+=5
    dfs(level+1)
    arr[level]=backup   # 원상복구

dfs(0)
print(Max)
```
### 원상복구-2
```py
def dfs(level,y,x):
    global max
    if level == 3:
        sum = 0
        for i in range(3):
            for j in range(3):
                sum += arr[i][j]
        if sum > max:
            max = sum
        return
    backup = [[0] * 3 for _ in range(3)]
    directy = [1,-1,0,0]
    directx = [0,0,1,-1]
    backup[y][x] = arr[y][x]
    arr[y][x] = (arr[y][x]*7)%10
    for i in range(4):
        dy = y+directy[i]
        dx = x+directx[i]
        if dy<0 or dy>2 or dx<0 or dx>2:
            continue
        backup[dy][dx] = arr[dy][dx]
        arr[dy][dx] = (arr[dy][dx] *7) %10
    for i in range(3):
        for j in range(3):
            dfs(level+1,i,j)
            for k in range(4):
                dy = y + directy[k]
                dx = x + directx[k]
                if dy < 0 or dy > 2 or dx < 0 or dx > 2:
                    continue
                arr[dy][dx] = backup[dy][dx]
            arr[y][x] = backup[y][x]
    arr[y][x] = backup[y][x]
    for i in range(4):
        dy = y+directy[i]
        dx = x+directx[i]
        if dy<0 or dy>2 or dx<0 or dx>2:
            continue
        arr[dy][dx] = backup[dy][dx]
arr=[
    [4,7,1],
    [3,5,8],
    [9,2,7]
]
max = 0
for i in range(3):
    for j in range(3):
        dfs(0, i, j)
print(max)
```
### 민코딩 38.5 디아블로 퍼즐 (어려움)
```py
def dfs(level):
    global flag
    if flag == 1:
        return
    if level == 6:
        return
    backup = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            backup[i][j] = arr[i][j]
    for i in range(n):
        for j in range(n-2):
            if arr[i][j] == 'A':
                if arr[i][j+1] == 'A' and arr[i][j+2] =='A':
                    flag = 1
                    return
    directy = [-1,-1,-1,0,0,1,1,1]
    directx = [-1,0,1,-1,1,-1,0,1]
    for i in range(1,n-1):
        for j in range(1,n-1):
            for k in range(7):
                dy = i+directy[k]
                dx = j+directx[k]
                if arr[dy][dx] == 'A':
                    move(i,j)
                    dfs(level+1)
                    for y in range(n):
                        for x in range(n):
                            arr[y][x] = backup[y][x]

def move(y,x):
        copy = [[0]*n for _ in range(n)]
        tmp = arr[y][x]
        for i in range(3):
            copy[y-1][x-1+i] = arr[1+y-i][x-1]
        for i in range(3):
            copy[y-1+i][x+1] = arr[y-1][x-1+i]
        for i in range(3):
            copy[y+1][x+1-i] = arr[y-1+i][x+1]
        for i in range(3):
            copy[y+1-i][x-1] = arr[y+1][x+1-i]
        for i in range(3):
            for j in range(3):
                arr[y+i-1][x+j-1] = copy[y+i-1][x+j-1]
        arr[y][x] = tmp


n = int(input())
arr = [list(input()) for _ in range(n)]
flag = 0
dfs(0)
if flag == 1:
    print('가능')
else:
    print('불가능')
```
### 섬크기 구하기
```py
n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]
result = 0
for i in range(n):
    for j in range(n):
        if arr[i][j] == 1:
            q = []
            q.append([i,j])
            while q:
                y, x = q.pop(0)
                directy = [0,1,0,-1]
                directx = [1,0,-1,0]
                for j in range(4):
                    dy = y+directy[j]
                    dx = x+directx[j]
                    if 0<=dy<n and 0<=dx<n:
                        if arr[dy][dx] == 1:
                            arr[dy][dx] = arr[y][x] + 1
                            q.append([dy,dx])
                            result+=1

print(result)
```
### 소방 훈련
```py
n = int(input())
arr = [list(input()) for _ in range(n)]
y1, x1 = map(int, input().split())

so = []
for i in range(n):
    for j in range(n):
        if arr[i][j] == 'A':
            so.append([i,j])
        if arr[i][j] == '$':
            ey,ex = i, j
backup = [['']*n for _ in range(n)]
min = 21e8
for k in range(n):
    for j in range(n):
        backup[k][j] = arr[k][j]
for j in range(len(so)):
    Y, X = so[j][0], so[j][1]
    result = 0
    q = []
    q.append([y1,x1,0])
    flag = 0
    visit = [[0]*n for _ in range(n)]
    visit[y1][x1] = 1
    while q:
        y,x,level = q.pop(0)
        if y == Y and x == X:
            if flag == 0:
                flag = 1
                result += level
                visit = [[0] * n for _ in range(n)]
                visit[y][x] = 1
                q = []
                q.append([y,x,0])
                continue
        if y == ey and x == ex:
            if flag == 1:
                result += level
                continue
        directy = [0,1,0,-1]
        directx = [1,0,-1,0]
        for i in range(4):
            dy = y+directy[i]
            dx = x+directx[i]
            if 0<=dy<n and 0<=dx<n:
                if visit[dy][dx] == 1:
                    continue
                if arr[dy][dx] == '#':
                    continue
                if arr[dy][dx] == '$':
                    if flag == 0:
                        continue
                    else:
                        visit[dy][dx] = 1
                        q.append([dy,dx,level+1])
                        continue
                visit[dy][dx] = 1
                q.append([dy,dx,level+1])
    if result < min:
        min = result

print(min)
```
# 프로그래머스 사용할때 global 대신 nonlocal

# 03.25
### swea 2382.미생물 격리
```py
T = int(input())
for t in range(1,T+1):
    di,dj = (0,-1,1,0,0),(0,0,0,-1,1)
    opp = [0,2,1,4,3]
    N, M, K = map(int , input().split())
    arr = [list(map(int, input().split())) for _ in range(K)]
    for _ in range(M):
        for i in range(len(arr)):
            arr[i][0] = arr[i][0] + di[arr[i][3]]
            arr[i][1] = arr[i][1] + dj[arr[i][3]]
            if arr[i][0] == 0 or arr[i][0] == N-1 or arr[i][1] == 0 or arr[i][1] ==N-1:
                arr[i][2]//=2
                arr[i][3] = opp[arr[i][3]]
        arr.sort(key=lambda x: (x[0],x[1],x[2]), reverse=True)

        i = 1
        while i < len(arr):
            if arr[i-1][0] == arr[i][0] and arr[i-1][1] == arr[i][1]:
                arr[i-1][2] += arr[i][2]
                arr.pop(i)
            else:
                i+=1
    ans = 0
    for i in range(len(arr)):
        ans += arr[i][2]

    print(f'#{t} {ans}')
```
### swea 13864.토너먼트 카드게임
```py
def group(ar):
    if len(ar) == 1:
        return ar
    else:
        middle = (len(ar)-1)//2
        left = ar[:middle+1]
        right = ar[middle+1:]
        if len(left) == 1 and len(right) == 1:
            if left[0][1] == 1:
                if right[0][1] == 2:
                    return right
                else:
                    return left
            elif left[0][1] == 2:
                if right[0][1] == 3:
                    return right
                else:
                    return left
            else:
                if right[0][1] == 1:
                    return right
                else:
                    return left
        else:
            left = group(left)
            right = group(right)
            if left[0][1] == 1:
                if right[0][1] == 2:
                    return right
                else:
                    return left
            elif left[0][1] == 2:
                if right[0][1] == 3:
                    return right
                else:
                    return left
            else:
                if right[0][1] == 1:
                    return right
                else:
                    return left

T = int(input())
for t in range(1,T+1):
    N = int(input())
    arr = list(map(int, input().split()))
    arr = list(enumerate(arr))
    ans = group(arr)
    print(f'#{t} {ans[0][0]+1}')
```
# 에라토스테네스의체(prime넘버 구하는거) / 유클리드호제법(LCM GCD을 위함)
# 우선순위 큐 (priority queue)
# 다익스크라 크루스칼
# 그리디 
# DP(동적계획법)
# hash